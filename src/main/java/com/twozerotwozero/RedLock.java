package com.twozerotwozero;

/**
 * @author xiaoma
 * @version V1.0
 * @Description: TODO
 * @date 2020/3/2 21:45
 */
public class RedLock {

    private String $1;

    /**
     * 在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，
     * 我们不用任何复制或者其他隐含的分布式协调算法。
     * 我们已经描述了如何在单节点环境下安全地获取和释放锁。
     * 因此我们理所当然地应当用这个方法在每个单节点里来获取和释放锁。在我们的例子里面我们把N设成5，
     * 这个数字是一个相对比较合理的数值，因此我们需要在不同的计算机或者虚拟机上运行5个master节点来保证他们大多数情况下都不会同时宕机。一个客户端需要做如下操作来获取锁：

         1.获取当前时间（单位是毫秒）。轮流用相同的key和随机值在N个节点上请求锁，
         在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。
         比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，
         这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，
         如果一个master节点不可用了，我们应该尽快尝试下一个master节点。
     2.客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），
     而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。
     3.如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。
     4.如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，
     客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。
     */
}
